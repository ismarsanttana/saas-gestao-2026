// Code generated by hand to espelhar sqlc; substitua ap√≥s `make sqlc`.
package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

type Queries struct {
	pool *pgxpool.Pool
}

func New(pool *pgxpool.Pool) *Queries {
	return &Queries{pool: pool}
}

func (q *Queries) QueryRowContext(ctx context.Context, sql string, args ...any) pgx.Row {
	return q.pool.QueryRow(ctx, sql, args...)
}

type InsertRefreshTokenParams struct {
	ID        uuid.UUID
	Subject   uuid.UUID
	Audience  string
	TokenHash string
	Expiracao time.Time
	CriadoEm  time.Time
}

func (q *Queries) GetUsuarioByEmail(ctx context.Context, email string) (Usuario, error) {
	row := q.pool.QueryRow(ctx, `SELECT id, nome, email, senha_hash, ativo, criado_em FROM usuarios WHERE email = $1`, email)
	var u Usuario
	if err := row.Scan(&u.ID, &u.Nome, &u.Email, &u.SenhaHash, &u.Ativo, &u.CriadoEm); err != nil {
		if err == pgx.ErrNoRows {
			return Usuario{}, ErrNotFound
		}
		return Usuario{}, err
	}
	return u, nil
}

func (q *Queries) GetUsuarioByID(ctx context.Context, id uuid.UUID) (Usuario, error) {
	row := q.pool.QueryRow(ctx, `SELECT id, nome, email, senha_hash, ativo, criado_em FROM usuarios WHERE id = $1`, id)
	var u Usuario
	if err := row.Scan(&u.ID, &u.Nome, &u.Email, &u.SenhaHash, &u.Ativo, &u.CriadoEm); err != nil {
		if err == pgx.ErrNoRows {
			return Usuario{}, ErrNotFound
		}
		return Usuario{}, err
	}
	return u, nil
}

func (q *Queries) UpdateUsuario(ctx context.Context, id uuid.UUID, nome, email string) error {
	cmd, err := q.pool.Exec(ctx, `UPDATE usuarios SET nome = $1, email = $2 WHERE id = $3`, nome, email, id)
	if err != nil {
		return err
	}
	if cmd.RowsAffected() == 0 {
		return ErrNotFound
	}
	return nil
}

func (q *Queries) ListSecretariasByUsuario(ctx context.Context, usuarioID uuid.UUID) ([]SecretariaWithRole, error) {
	rows, err := q.pool.Query(ctx, `SELECT us.secretaria_id, s.nome, s.slug, us.papel
FROM usuarios_secretarias us
JOIN secretarias s ON s.id = us.secretaria_id
WHERE us.usuario_id = $1
ORDER BY s.nome`, usuarioID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var result []SecretariaWithRole
	for rows.Next() {
		var item SecretariaWithRole
		if err := rows.Scan(&item.SecretariaID, &item.Secretaria, &item.Slug, &item.Papel); err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	return result, rows.Err()
}

func (q *Queries) HasProfessorTurma(ctx context.Context, professorID uuid.UUID) (bool, error) {
	var exists bool
	if err := q.pool.QueryRow(ctx, `SELECT EXISTS (SELECT 1 FROM professores_turmas WHERE professor_id = $1)`, professorID).Scan(&exists); err != nil {
		return false, err
	}
	return exists, nil
}

func (q *Queries) GetCidadaoByEmail(ctx context.Context, email string) (Cidadao, error) {
	row := q.pool.QueryRow(ctx, `SELECT id, nome, email, senha_hash, ativo, criado_em FROM cidadaos WHERE email = $1`, email)
	var c Cidadao
	if err := row.Scan(&c.ID, &c.Nome, &c.Email, &c.SenhaHash, &c.Ativo, &c.CriadoEm); err != nil {
		if err == pgx.ErrNoRows {
			return Cidadao{}, ErrNotFound
		}
		return Cidadao{}, err
	}
	return c, nil
}

func (q *Queries) GetCidadaoByID(ctx context.Context, id uuid.UUID) (Cidadao, error) {
	row := q.pool.QueryRow(ctx, `SELECT id, nome, email, senha_hash, ativo, criado_em FROM cidadaos WHERE id = $1`, id)
	var c Cidadao
	if err := row.Scan(&c.ID, &c.Nome, &c.Email, &c.SenhaHash, &c.Ativo, &c.CriadoEm); err != nil {
		if err == pgx.ErrNoRows {
			return Cidadao{}, ErrNotFound
		}
		return Cidadao{}, err
	}
	return c, nil
}

func (q *Queries) InsertRefreshToken(ctx context.Context, arg InsertRefreshTokenParams) (TokenRefresh, error) {
	row := q.pool.QueryRow(ctx, `INSERT INTO tokens_refresh (id, subject, audience, token_hash, expiracao, criado_em, revogado)
VALUES ($1, $2, $3, $4, $5, $6, FALSE)
RETURNING id, subject, audience, token_hash, expiracao, criado_em, revogado`, arg.ID, arg.Subject, arg.Audience, arg.TokenHash, arg.Expiracao, arg.CriadoEm)
	var t TokenRefresh
	if err := row.Scan(&t.ID, &t.Subject, &t.Audience, &t.TokenHash, &t.Expiracao, &t.CriadoEm, &t.Revogado); err != nil {
		return TokenRefresh{}, err
	}
	return t, nil
}

func (q *Queries) GetRefreshTokenByHash(ctx context.Context, tokenHash string) (TokenRefresh, error) {
	row := q.pool.QueryRow(ctx, `SELECT id, subject, audience, token_hash, expiracao, criado_em, revogado FROM tokens_refresh WHERE token_hash = $1`, tokenHash)
	var t TokenRefresh
	if err := row.Scan(&t.ID, &t.Subject, &t.Audience, &t.TokenHash, &t.Expiracao, &t.CriadoEm, &t.Revogado); err != nil {
		if err == pgx.ErrNoRows {
			return TokenRefresh{}, ErrNotFound
		}
		return TokenRefresh{}, err
	}
	return t, nil
}

func (q *Queries) RevokeRefreshToken(ctx context.Context, tokenHash string) error {
	cmd, err := q.pool.Exec(ctx, `UPDATE tokens_refresh SET revogado = TRUE WHERE token_hash = $1`, tokenHash)
	if err != nil {
		return err
	}
	if cmd.RowsAffected() == 0 {
		return ErrNotFound
	}
	return nil
}

func (q *Queries) InvalidateOtherRefreshTokens(ctx context.Context, subject uuid.UUID, audience, keepHash string) error {
	_, err := q.pool.Exec(ctx, `UPDATE tokens_refresh SET revogado = TRUE WHERE subject = $1 AND audience = $2 AND token_hash <> $3`, subject, audience, keepHash)
	return err
}
